// 5개의 난수 발생 => 출력 / 평균 출력한다
public class 배열_2 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
	/*	int a1=(int)(Math.random()*100)+1;
		int a2=(int)(Math.random()*100)+1;
		int a3=(int)(Math.random()*100)+1;
		int a4=(int)(Math.random()*100)+1;
		int a5=(int)(Math.random()*100)+1;
		
		System.out.println(a1+" "+a2+" "+a3+" "+a4+" "+a5); // 39 25 17 11 89
		System.out.printf("평균:%.2f\n",(a1+a2+a3+a4+a5)/5.0); // 평균:36.20 */
		
		int[] arr=new int[5]; // new를 이용하면 자동으로 0값 초기화
		for(int i=0;i<5;i++)
		{
			arr[i]=(int)(Math.random()*100)+1;
		}
		// 출력 => 향상된 for문 => for-each => 데이터 출력 => 배열, 컬렉션에서만 사용 가능
		// 값 추가, 수정,...불가능 => 출력만 담당 => 데이터가 모아져 있어야 사용 가능
		for(int i:arr)
		{
			System.out.print(i+" "); //  39 25 17 11 89 
		}
		/*
		 * 	new를 이용하여 메모리 할당
		 * 	=> 자동 초기화
		 * 	int => 0
		 * 	double => 0.0
		 * 	long => 0L
		 * 	float => 0.0F
		 * 	boolean => false
		 * 	char => '\0'
		 * 	String => null
		 * 
		 * 	>>> 배열, 클래스 저장 위치
		 *
		 *	메모리 구조 => 관리 (JVM)
		 *	--------------------
		 *	Method Area/static
		 *	main => (교재 5장)
		 *	--------------------
		 *	Stack => 지역변수 => 관리 (메모리 자체 관리)
		 *		  => {}이 종료되면 자동으로 사라진다
		 *	--------------------
		 *	Heap => 배열의 실제값, 클래스 실제값 => 관리 (프로그래머)
		 *		 => 프로그래머가 관리를 소홀시한다 => 자동 메모리 회수 (가비지 컬렉션)
		 *			~~~~~~~~~~~~~~~~~~ => 바로 회수 X => 프로그램 종료 시 회수
		 *								=> 메모리 누수 현상
		 *	--------------------
		 *		int a=10;b=20;
		 *	0-------------
		 *		// 사용중
		 *	4-------------
		 *		10 --------- a
		 *	8-------------
		 *		// 사용중
		 *	12-------------
		 *		20 --------- b
		 *	16-------------
		 *
		 *	int[] arr=new int[5]
		 *		  new => 요청한 메모리를 생성 => 생성된 위치의 주소값을 배열변수에 넘겨준다
		 *		  스택			  힙
		 *					| 100  104 	   108	   112	   116 (int->4byte이므로)
		 *	arr = 0x100		   -----------------------------------
		 *		========>	   0 |	0	|	0	|	0	|	0	|
		 *					  |-----------------------------------
		 *						0	1		2		3		4 => 인덱스 번호
		 *	주소 참조 변수		 0x100 => 연속적인 메모리 구조
		 *	실제값 : arr[0],...  arr+0*4 => 100
		 *		   ------			arr+1*4 => 100+4
		 *		  일반 변수 취급				arr+2*4 => 100+8
		 *											arr+3*4 => 100+12
		 *													arr+4*4 => 100+16
		 **					| arr의 첫번째 값 요청 => arr[0] => 일반 변수와 동일 역할 수행
		 *					| arr의 두번째 값 요청 => arr[1]
		 *					| arr의 세번째 값 요청 => arr[2]
		 *					| arr의 네번째 값 요청 => arr[3]
		 *					| arr의 다섯번째 값 요청 => arr[4]
		 *					| ...
		 *						=> 해당 위치의 값을 인덱스로 표현한다 (0번부터 시작)
		 *						=> 생성이 되면 삭제 및 추가 불가능 (고정)
		 *						=> 인덱스 번호가 0부터 순차적으로 만들어진다
		 *						=> for문(반복문) 처리가 편하다
		 *
		 *		int[] arr=new int[3];
		 *		=> arr[0] arr[1] arr[2] (변수 3개)
		 *		int a,b,c;
		 *		a=100;
		 *		b=200;
		 *		c=300;
		 *
		 *		arr[0]=100;
		 *		arr[1]=200;
		 *		arr[2]=300;
		 * 
		 */
	}

}
