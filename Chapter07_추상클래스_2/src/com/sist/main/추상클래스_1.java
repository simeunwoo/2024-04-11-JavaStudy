package com.sist.main;
/*
 * 	# 일반 클래스
 * 	= 구성 요소
 * 	{
 * 		-------------------
 * 		변수
 * 		=> 따로 저장 변수 : 인스턴스 => 새로운 메모리 공간을 만들어서 저장 : new 사용
 * 		=> 한개를 가지고 사용하는 변수 => static
 * 		-------------------
 * 		생성자 : 변수에 대한 초기화
 * 				윈도우 / 웹 / 데이터베이스 : 시작과 동시에 처리
 * 				화면 UI / 자동 로그인, 쿠키 / 드라이버 등록
 * 		=> 반드시 필요하다 : 메모리 저장 시에 호출
 * 						=> 없는 경우에는 컴파일러에 의하여 자동으로 추가
 * 			필요 없는 경우에는 생략할 수 있다
 * 		=> 여러개를 만들 수 있다
 * 			=> 디폴트 생성자 : 매개 변수가 없는 생성자
 * 			=> 매개 변수가 있는 생성자 => 사용자로부터 초기값을 받아서 저장
 * 			=> 클래스 내에서 생성자를 호출할 때는 this()를 이용한다 => 생성자 내에서만 호출 가능 => 한번만 호출 / 첫줄에 사용
 * 			=> super()는 상속을 받은 경우에 사용
 * 			=> 자동 처리 => 컴파일러에 처리
 * 
 * 		1. 모든 클래스는 Object 상속을 받는다 => Object 상속을 생략할 수 있다
 * 			public class A extends Object
 * 			=> Object에서 제공하는 모든 기능 사용이 가능
 * 				=> 객체 비교 : equals()
 * 				=> 소멸자 : finalize()
 * 				=> 복제 : clone()
 * 				=> 주소 출력 : toString()
 * 
 * 		2. import가 생략
 * 			import java.lang.*;
 * 				   ~~~~~~~~~~~ String, Math, System ...
 * 
 * 		3. 메소드
 * 			void => return을 생략하면 => 자동으로 추가
 * 
 * 		4. 상속
 * 			class A
 * 			{
 * 			}
 * 			class B extends A
 * 			{
 * 				public B(){
 * 					super() // 생략 가능
 * 							// => 생략할 수 없는 내용 :
 * 							// 상속을 내리는 클래스의 생성자가 매개 변수를 가지고 있는 경우 => 생략 불가
 * 				}
 * 			}
 * 			===> super() (상위 클래스의 메모리 할당) => 자신의 메모리 할당
 * 				super => 상속 받은 변수/메소드
 * 				this => 추가된 변수/메소드
 * 				===> this, super에 있는 변수/메소드 사용이 가능
 * 
 * 		5. 예외 처리가 생략 => 자바의 모든 클래스는 예외 처리를 가지고 있다
 * 			예외 처리 : 컴파일 시 처리 : javac / 실행 시 (생략이 가능) : java
 * 			javac : 파일 입출력, 네트워크, 쓰레드, 데이터베이스, 웹 ...
 * 			java : 사용자의 입력=>처리, 정수 입력
 * 
 * 			에러 방지
 * 			=> 에러 : 소스 상에서 수정할 수 없는 에러
 * 				ex) 메모리를 할당할 공간이 없다, 한글이 깨졌다 ...
 * 			=> 예외 처리 : 소스 상에서 수정 가능한 에러
 * 				ex) 정수를 입력해야 되는데 실수를 입력했다, 파일명을 잘못 적었다 ...
 * 		-------------------
 * 		기능 처리 (사용자 요청 처리) => 메소드
 * 		=> 요청은 한개만 요청이 가능하게 만든다
 * 		=> 메소드는 반드시 한개 요청에 대한 처리만 한다
 * 			예) 에러 빈번하게
 * 			1. 사용자 입력 (요청값 오류)
 * 			2. 프로그래머의 실수
 * 	
 * 		NullPointerException : 윈도우 / ClassCastException : 객체 형변환 / ArrayIndexOutOfBoundsException : 배열 범위 초과
 * 		-------------------
 * 		메소드 : 구현을 반드시 해야된다
 * 			선언부
 * 			{
 * 
 * 			} // 메모리 저장
 * 	}
 * 
 * 	# 추상 클래스 : 사용자 정의는 거의 없다 => 확장된 개념 (인터페이스)
 * 				=> 라이브러리에 추상 클래스가 많이 존재
 * 				   ------- 상속 => 오버라이딩을 하는 이유
 * 
 * 	=> 형식) => 구현이 안된 메소드를 포함 => 미완성된 클래스
 * 			  ------------------- 설계만 한다 => 상속을 내려서 사용 => 익명의 클래스를 이용한다
 * 
 * 		[접근지정어] abstract class ClassName
 * 		{
 * 			-----------------------------
 * 			변수는 일반 클래스와 동일
 * 			-----------------------------
 * 			생성자
 * 			-----------------------------
 * 			구현된 메소드 : 상속 받은 클래스가 동일한 기능을 수행
 * 			-----------------------------
 * 			구현이 안된 메소드 (추상 메소드) : 상속 받은 클래스마다 기능은 동일한데 구현이 다른 경우 => 선언
 * 			[접근지정어] abstract 리턴형 메소드명(매개 변수...); // 뒤에 ;를 꼭 써야 한다
 * 			=> 프로그램에 맞게 구현을 해서 사용한다
 * 			-----------------------------
 * 		}
 * 
 * 		=> 주로 사용되는 곳은 클래스마다 기능은 동일한데 => 구현 내용이 틀린 경우 => 선언 => 유지 보수가 편리하게 만든다
 * 		=> 사이트마다 약간씩 틀리다 ... : 로그인, 로그아웃, 회원 가입 ...
 * 			=> 네이버 : Ajax / 네이트 : 일반 JSP / 아시아나항공 : VueJS
 * 			=> 벤치 마킹 => 기능 (설계) => 추상 클래스
 * 		=> 상속이 안되는 소스
 * 			생성자, static, 초기화 블록 => 상수 (변수/메소드)
 * 		=> 오버라이딩 프로그램 : 일반 클래스, 추상 클래스, 인터페이스
 * 			오버라이딩 => 메소드명 동일, 매개 변수 동일, 리턴형 동일, 접근지정어는 다를 수 있다 (확장)
 * 
 * 		abstract class A
 * 		{
 * 			abstract void display(); // 상속을 내리면 반드시 구현해서 사용
 * 			-------- 선언만 한다
 * 			=> default
 * 		}
 * 		class B extends A
 * 		{
 * 			void display(){} => 동일
 * 			---------------------------
 * 			protected void display(){}
 * 			public void display(){}
 * 			--------------------------- 접근 범위 확장이 가능하다
 * 			=> 잘 모르는 경우에는 public
 * 		}
 * 
 * 		interface A
 * 		{
 * 			(public static final) int a=10; // 오류 발생 => 변수/상수
 * 
 * 			(public abstract) void display(); // 선언만된 메소드만 가지고 있다 / 앞에 public abstract이 생략됨
 * 		}
 * 		class B implements A
 * 		{
 * 			void display(){} // 오류 발생
 * 		}
 */

class A
{
//	public A(){} // 생성자 생략 가능
}
class B extends A
{

	public B() {
//		super(); // super() 생략 가능
	}
	
}
class C
{
	public C(int a)
	{
		
	}
}
// D : 하위 클래스 => this, super / C : 상위 클래스 => this, super
// 상속을 받아서 새로운 확장된 클래스를 만들어서 사용
class D extends C
{
	public D()
	{
		super(10); // 상위 클래스에 매개 변수가 있는 경우에는 반드시 super를 이용하여 호출해야 사용 가능
		// 사용자 정의는 거의 없다 => 라이브러리에서 호출 시에 반드시 super() 호출
		// super(), this() => 생성자 내에서 호출이 가능, 반드시 첫줄에서 호출한다
		// super()와 this() 둘중에 한개만 호출 가능 (동시에 호출 불가능)
		// 상위 클래스 제어 => super, 생성자 super()
		// 자신 클래스 제어 => this, 생성자 this()
	}
}

abstract class AAA
{
	public abstract void display();
}

public class 추상클래스_1 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
	//	A a=new A();
	//	B b=(B)a;
		
	}

}
