package com.sist.chapter05;
/*
 * 	변수 : 한개 저장 메모리 공간
 * 	= 데이터형
 * 		정수 : int, long, 배열 (byte) => 네트워크 전송, 파일 읽기
 * 		실수 : double
 * 		논리 : boolean
 * 		문자열 : String
 * 		=> 사용자 정의 클래스
 * 		------------- 조합
 * 	= 배열 => 같은 데이터형의 변수 여러개를 한번에 저장 (이름이 한개) => 인덱스 (0 ...)
 * 			같은 데이터형만 모아서 관리 / 저장 갯수를 지정 (고정적)
 * 	= 클래스 => 다른 데이터형을 저장할 수 있다
 * 			저장 갯수를 지정할 필요 없다 => 필요한 갯수만큼 new를 사용한다
 * 			=> 한개에 대한 정보 : 영화 정보, 뮤직 정보 ...
 * 
 * 	연산 처리 / 제어문 => 메소드 (기능 처리)
 * 	프로그램은 묶음 싸움 => 다음에 다시 활용 (재사용)
 * 		=> 변수 : 배열 / 클래스
 * 		=> 연산 / 제어문 => 명령문 => 메소드
 * 		=> 변수 => 초기화 (생성자)
 * 
 * 	클래스 구성 요소
 * 	1. 변수 (멤버 변수)
 * 	2. 메소드 => 변수에 대한 활용
 * 	3. 생성자 => 변수에 초기화
 * 
 * 	클래스는 한가지 기능 => 프로그램에서는 여러가지 기능이 필요
 * 	=> 클래스 여러개를 만든다 => 서로 연결 => 접근에 범위 (접근지정어)
 * 
 * 	재사용 기법
 * 	=> 상속 : 변경해서 사용
 * 	class A
 * 	class B extends A => is-a
 * 	class C
 * 	{
 * 		A a=new A(); => has-a
 * 	}
 * 	=> 포함 : 있는 그대로 사용
 * 	=> 필요할 시 변경 : 오버라이딩 / 새로운 기능 추가 : 오버로딩 => 유지 보수
 * 	-------------------------------------------------------- 객체 지향의 3대 특성
 * 	1. 캡슐화 : 데이터 보호 목적
 * 	2. 상속 / 포함 : 재사용
 * 	3. 다형성 : 오버로딩 / 오버라이딩
 * 		=> 오버로딩 : 새로운 기능 추가 (new)
 * 		=> 오버라이딩 : 수정 (modify)
 * 	4. 추상화 : 사물을 단순화 => 클래스의 기본
 * 		사원 => 사번, 이름, 부서
 * 		학번 => 학번, 이름, 학교
 * 		계산기 => 정수/정수 (문자열), 연산자
 * 	-------------------------------- 클래스의 종류
 * 	일반 클래스 : ArrayList, String, Scanner ...
 * 	추상 클래스 / 인터페이스 : 미완성 => 개발자가 완성해서 사용 : Shape, Animal ...
 * 						메소드가 미구현 : 프로그램에 맞게 구현 사용 => 버튼 클릭
 *	추상 클래스 => 설계 => 게시판을 만들어라 => 필요한 것 : 글쓰기, 상세보기, 찾기...
 *	--------------------------------------------------------------- 프로그램의 안전성 => 종료하지 않는 프로그램 => 예외 처리 (8장)
 *	라이브러리 => 조립 => 암기
 *	Math => random() / ceil() => 요 2개만 외우면 됨
 *
 *	> 세부적
 *	클래스 : 변수, 메소드, 생성자, 접근지정어
 *	변수 : 인스턴스변수, static 변수, 지역변수
 *	메소드 : 인스턴스메소드, static 메소드, 선언만 하는 메소드
 *	생성자 : 생성자, 초기화 블록 => 동시에 사용하지는 않는다
 *	접근지정어 : private => 변수 / public => 나머지
 *
 *	> 클래스의 구성 요소 : 무조건 다 사용하는 것은 아니다 => 필요한 것만 사용한다
 *	*** 순서는 노상관 => 단, 권장사항 : 변수 => 생성자 => 메소드
 *	class ClassName
 *	{
 *		------------------------------- 변수 선언
 *		[접근지정어] [옵션] 데이터형 변수명 => 노출 방지
 *		접근지정어 : private
 *		옵션 : static : 공통적인
 *			final : 마지막 (상수)
 *			abstract : 추상적인, 구현이 안된 ... (메소드에서 사용)
 *			synchronized : 동기적인 (메소드에서 사용)
 *		인스턴스변수 : 여러개를 동시에 저장 => new를 이용하여 생성 (new를 이용하면 메모리 공간이 따로 생성)
 *				영화 정보 / 음악 정보 ...
 *		정적변수 (static) : 공통으로 사용되는 변수 => Method Area => 메모리 공간을 한개만 사용
 *						전체 데이터 목록
 *						학교명 / 학원명 / 사이트명 ...
 *		*** 대부분은 인스턴스변수를 사용한다
 *		*** 사용할 수 있는 변수
 *			= 기본형
 *			= 배열
 *			= 클래스
 *		*** 클래스 안에서는 변수가 없는 경우도 있다 (필요한 경우에만 사용)
 *		*** 변수 => 저장할 때 반드시 값을 필요로 한다 : 초기값
 *		클래스 영역에 설정되는 변수는 자동 초기값
 *		=> int=0 / long=0L / double=0.0 / char='\0' / boolean=false / String(클래스)=null
 *		=> 프로그램에 따라 => 다른 초기값이 필요할 수도 있다 => ex) int a=100; : 명시적인 초기화
 *		=> int a=난수 발생, 파일 읽기, 사용자의 입력값 : 클래스 블록에서는 사용 불가능
 *		------------------------------- 생성자 선언
 *		=> 명시적인 초기화가 안되는 경우 => 구현해서 값을 가지고 오는 경우
 *		=> 멤버변수의 초기화
 *		=> 시작과 동시에 처리하는 명령문이 존재할 때
 *			화면 UI / 자동 로그인 / 서버에 연결 / 서버 가동 / 데이터베이스 연결
 *		=> 없는 경우에는 생략할 수 있다 : 프로그램 구동 시에 반드시 생성자가 필요하다 => 컴파일러에 의하여 자동 추가 (디폴트 생성자)
 *		디폴트 생성자 : 매개변수가 없는 생성자
 *
 *		특징
 *		= 클래스명과 동일
 *		= 리턴형이 없다
 *		= 객체 생성 시 호출 => new를 동반한다
 *		= 여러개의 생성자를 만들 수 있다 => 같은 이름의 메소드를 제작 : 오버로딩 (중복 함수 정의)
 *								=> 매개변수로 구분 : 1. 갯수가 다르다 / 2. 데이터형이 다르다 => JVM이 알아서 찾아준다
 *								=> 접근지정어 / 리턴형은 관계 없다
 *		class A
 *		{
 *			A(){}
 *			A(){}
 *			A(){}
 *			A(){}
 *			A(){}
 *		}
 *		new A(); // 생성자 호출
 *
 *		=> 오버로딩
 *		void display(int a,char c,double d)
 *		void display(int a,double d1,int b)
 *	^	void display(double a,double b,double c)
 *		void display(char a,int d,int b)
 *
 *		display(10.5,'A',10) // double char int
 *		=> 해당 매개변수가 없는 경우 => 가장 근접한 것을 찾는다 => 데이터형이 큰 것 위주부터
 *		===> double double double (3번째)로 간다
 *
 *		class A
 *		{
 *			public void display(){}
 *		}
 *		A a=new A();
 *		a.display();
 *		=> 위의 요 두줄을 요렇게 바꿀 수 있다
 *		=> new A().display();
 *
 *		*** 생성자는 다른 클래스에 연결 시에 사용한다 => public
 *		*** 객체 지향 프로그램은 클래스 1개로 제작하는 것이 아니라 클래스 여러개를 만들어서 연결 => 클래스->레고블록 (부폼)
 *		------------------------------- 메소드 선언
 *		= 인스턴스메소드
 *		public 리턴형 메소드명(매개변수 목록) => 객체명.메소드명
 *		{
 *		}
 *
 *		= 정적메소드
 *		public static 리턴형 메소드명(매개변수 목록) => 클래스명.메소드명
 *		{
 *		}
 *
 *		= 추상메소드
 *		public 리턴형 메소드명(매개변수 목록); => 호출이 불가능 => 구현 후에 사용
 *
 *		기능 구현 => 사용 입력을 받는 경우 : 매개변수, 요청 처리에 대한 결과 : 리턴형 (void)
 *		=> 입력값
 *		=> 요청 처리
 *		=> 결과값
 *
 *		=> 게시판 : 글쓰기, 수정하기, 목록 출력, 상세 보기, 삭제하기, 검색하기 => '답변, 댓글' 기능 추가 : 유지 보수
 *			=> 기능 추가를 위하여 => 게시판을 상속 => 확장할 수 있다 => 상속 기호 : extends
 *		-------------------------------
 *	}
 *
 *	접근지정어
 *	=> private : 멤버변수 => 비공개
 *	=> public : 생성자, 클래스, 메소드 => 공개
 */
public class 클래스_1 {
	static void display(int a)
	{
		System.out.println("int");
	}
	
	static void display(double d)
	{
		System.out.println("display call...");
	}
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		display(100); // display(int a)가 있는 경우 : int로 호출 / 없는 경우 : display call...로 호출
		display('A'); // display(int a)가 있는 경우 : int로 호출 / 없는 경우 : display call...로 호출
		
		int aa=10;
		System.out.println(aa); // 10
		System.out.println(10); // 10
	}

}
