/*
 * 	메소드 : 기능처리 (사용자 요청처리) => 한개의 기능만 수행 가능하게 만드는 명령문의 집합
 * 			명령문
 * 			1. 변수 선언
 * 			2. 연산 처리
 * 			3. 제어문 처리
 * 	1) 메소드 구조
 * 		[접근지정어][옵션] 리턴형 메소드명(매개변수목록) : 선언부 (원형)
 * 		{
 * 			구현
 * 			...
 * 			...
 * 			return 값;
 * 			=> 메소드는 종료 => return에서 종료
 * 				=> 중간에 올 수 있다
 * 			=> return은 생략 불가능
 * 				예외 => void를 이용하는 경우 생략하지만
 * 					   컴파일러에 의해 자동으로 return이 첨부된다
 * 		}
 * 
 * 		접근지정어 : 다른 클래스에서 접근하는 범위
 * 		------- public / protected / private / default => 같은 폴더에서만 접근이 가능
 * 		옵션 :
 * 			1) default : 없는 경우
 * 		***	2) static : 자동 메모리 할당 => 공유
 * 			3) abstract : 추상 메소드 => 선언만 한다 => 프로그램에 맞게 구현해서 사용
 * 							ex) 버튼 클릭 / 마우스 클릭 / 키보드
 * 			4) final : 종단 메소드 => 수정이 안되는 메소드
 * 
 * 		리턴형 : 사용자 요청에 대한 결과값
 * 			=> 반드시 1개만 전송, 여러개일 때는 배열/클래스
 * 			   ------------- 기본형 (정수,실수,문자,논리)
 *
 *		메소드명 : 변수 식별자와 동일
 *
 *		매개변수 : 여러개 사용 가능 => 사용자가 보내주는 값
 *
 *		메소드 호출 : 메소드를 호출 시에는 메소드는 처음부터 끝까지 사용
 *					=> 원래 호출한 위치로 복귀
 *			void display()
 *			{
 *				1 --------------- 3
 *				2 --------------- 4
 *				3 --------------- 5
 *			}
 *			main()
 *			{
 *				1 ------------ 시작 1
 *				2 --------------- 2
 *				display(); ------ 메소드 블록으로 이동
 *				3 --------------- 6
 *				4 --------------- 7
 *			}
 *		=> 1. 반복적인 문장이 있는 경우 (반복 제거)	
 *		=> 2. 구조적인 프로그램 => 단락 (수정, 오류처리)
 *		=> 3. 재사용 => main 내에서는 다른 클래스에서 호출 불가능
 *					=> 복붙 (X) / 있는 그대로 호출해서 사용 (O) => 메소드
 *		=> 4. 객체 지향 프로그램은 클래스와 클래스의 상호 연결
 *		=> 클래스 / 기능 / 조립
 *				   |	 |
 *				   |	메인 보드 (main이 있는 클래스)
 *				  CPU, 메모리, 하드디스크, 사운드,...
 *
 *		예) 사용자가 로그인 요청
 *			=> id,pwd : 매개변수 / boolean : 결과값
 *
 *			사용자가 아이디 중복 체크
 *			=> id : 매개변수 / boolean : 결과값
 *
 *			웹 => 매개변수 (이미지 클릭, 페이지번호 클릭, 입력(검색어))
 *			   => 화면 이동 => return
 *			   => 출력할 내용이 많은 경우 => 배열/컬렉션
 *
 *		매개변수 전송법
 *		-----------
 *		1. 값 전송 => 메모리를 따로 만들어서 처리
 *			Call By Value
 *			기본형 => 원본은 유지
 *		2. 주소 전송 => 메모리가 같은 곳에서 전송
 *			배열 / 클래스 => 원본이 변경
 *			Call By Reference
 *			예외) => String (일반 기본형과 동일)
 *
 *		int[] arr={1,2,3,4,5};
 *		int[]temp=arr;
 *		=> temp[0]=1;
 */
public class 메소드정리_1 {
	// call by value => 실제 값만 전송 => 다른 메모리 생성 (기본형, String)
	// call by reference => 메모리 주소를 넘겨준다 => 같은 메모리 제어 (배열, 클래스)
	
	static void rand(int[] arr)
	{
		System.out.println("arr="+arr); // arr=[I@6f2b958e / 주소가 같은 경우에는 같은 메모리를 제어
		for(int i=0;i<arr.length;i++)
		{
			arr[i]=(int)(Math.random()*100)+1;
		}
	}
	public static void main(String[] args) {
		// TODO Auto-generated method stub
/*		int[] nums=new int[5]; // nums[]=new int[5] => nums[5]
		System.out.println("nums="+nums); // nums=[I@6f2b958e
		rand(nums);
		for(int i:nums)
		{
			System.out.print(i+" "); // 5 4 35 44 95 
		}
		*/
		
		int[] arr= {10,20,30,40,50};
		int[] temp=arr;
		// temp는 arr의 별칭 => temp=arr => 기본형은 주소를 가지고 있지 않는다 => 값만 전송
		temp[1]=200; // 자신의 메모리를 넘겨주기 때문에 넘겨준 배열 자체가 변경될 수 있다
		System.out.println(temp[1]); // 200
		System.out.println(arr[1]); // 200
	}

}
