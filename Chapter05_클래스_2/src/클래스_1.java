/*
 * 	프로그램
 * 
 * 	요구사항 분석 ===> 데이터베이스 설계 ===> 화면 UI ===> 구현 ===> 테스트 ===> 배포
 * 	1) 필요한 데이터	데이터 값을 저장					웹 프로그래머			발표
 * 	2) 기능 설정
 * 	---------- 클래스 (설계)
 * 	=> 프로그램에 필요한 데이터 -> 변수
 * 	=> 기능 설정			 -> 메소드
 * 	--------------------
 * 	변수의 집합 + 메소드
 * 		|
 * 	   초기값 => 생성자
 * 	-------------------- 관리 => 영역 (객체) => 메모리에 저장 후 사용
 * 											--------- 객체
 * 
 * 	현실 세계에 있는 모든 사물 => 단순화
 * 	예)
 * 		사원 => 시뮬레이션 (가정)
 * 		=> 프로그래머가 알 수 있게 설계
 * 		사번 / 이름 / 부서명 / 직위 / 입사일 / 연봉 / 그눔지 => 변수 => 한명에 대한 설계
 * 		출근한다 / 퇴근한단 / 점심을 먹는다 ... 메소드
 * 	1) 객체 지향 프로그램
 * 		1. 변수 설정 => 어떤 데이터를 관리 (눈에 보인다)
 * 		2. 기능 => 메뉴
 * 	2) 설계
 * 		--------------- 설계 => 한개에 대해서만 설계 => new를 이용해서 여러개를 저장
 * 						맛집 1개, 학생 1명, 영화 1개
 * 		class ClassName
 * 		{
 * 		}
 * 		--------------- 메모리에 저장 => 관리
 * 	3) 클래스의 구성 요소
 * 		class className
 * 		{
 * 			------------------------
 * 			변수묶음
 * 
 * 			1. 변수의 종류
 * 			# 객체변수 => new를 이용해서 저장 시마다 메모리가 달라진다 (저장 공간이 따로 생긴다)
 * 				=> 인스턴스 변수 (메모리에 저장된 상태) => (객체 = 인스턴스)
 * 			# 공통변수 => 모든 객체가 동일한 변수를 사용
 * 				=> static => 메모리 공간을 한개만 생성
 * 
 * 			2. 데이터를 보호 : 다른 프로그램에서 사용이 안되게 만든다 => 감춘다 (은닉화)
 * 			   --------- 자체 프로그램에서는 사용 가능 (캡슐화)
 * 			   --------- 접근지정어
 * 			------------------------
 * 			초기화 (변수)
 * 
 * 			1. 명시적인 초기화
 * 				int a=10; => 특별한 경우 아니면 거의 사용 X
 * 
 * 			2. 초기화 블록
 * 				=> 인스턴스 블록
 * 				class ClassName
 * 				{
 * 					변수
 * 					{
 * 						인스턴스 블록 => 구현 => 웹에서 주로 사용
 * 								=> 자동 로그인, 쿠키 읽기, 세션 등록 ... 데이터베이스 연동
 * 								=> 윈도우에서 화면 UI
 * 								=> 인스턴스, static 변수 초기화가 가능
 * 					}
 *
 * 				}
 * 				*** 클래스 영역
 * 				class ClassName
 * 				{
 * 					구현(X), 선언만 가능
 * 					------ 연산자/라이브러리 메소드 호출, 파일 읽기, 데이터베이스 연동, 제어문 => 구현
 * 							{} 안에서 사용
 * 				}
 * 
 * 				=> 정적 블록
 * 				class ClassName
 * 				{
 * 					static
 * 					{
 * 						static 변수만 초기화 가능 => new를 이용하지 않고 자동으로 저장이 되게 만든다
 * 						---------- 단점 : 저장된 모든 객체가 공통으로 사용하는 변수
 * 					}
 * 				}
 * 
 * 				=> 보통 사용하는 초기화
 * 					=> 생성자 => 메모리에 저장 시에 반드시 호출
 * 							   ---------
 * 								| new Scanner()
 * 									  --------- 생성자 => 클래스명과 동일
 * 								   |	| 생성자는 변수의 초기화 => 값을 저장
 * 								  연산자
 * 								1. 클래스의 메모리의 크기를 확인
 * 								2. 메모리에 저장 => 메모리 확보 => 메모리 주소를 객체에 전송
 * 
 * 				예)
 * 				class A
 * 				{
 * 					int aa; => 0으로 초기화 => 클래스 영역에서는 자동으로 초기화
 * 					int bb; => 0으로 초기화
 * 				}
 *
 * 				int[] arr={1,2}
 *
 *				-- arr --
 *				0x100		 0x100의 첫번째값 0x100의 두번째값
 *							 arr[0]		arr[1] => 인덱스를 이용하는 방법 => 메모리 크기가 동일
 *				--------- => -----------------
 *								 1	 |	 2
 *							 |----------------
 *							0x100
 *						*** 데이터를 설계 => 메모리가 크기가 다른 것이 있다
 *
 *			1) 클래스 저장
 *				A a=new A()
 *					---
 *					 |
 *				--- a ---
 *				  0x100
 *				---------	=>	0x100 -----------
 *								------ aa
 *									0
 *								---------
 *
 *								------ bb
 *									0 => 초기값을 저장해주는 역할 => 생성자
 *								---------
 *
 *				A b=new A() => new => 따로 메모리가 생성이 된다
 *					---			 => 접근하는 범위는 해당 주소에서만 사용 가능
 *					 |
 *				--- b ---
 *				  0x100
 *				---------	=>	0x200 -----------
 *								------ aa
 *									0
 *								---------
 *
 *								------ bb
 *									0
 *								---------
 *
 *				=> new는 사용할 때마다 따로 메모리 생성 (클래스 크기만큼) => 제한 (하드디스크 크기만큼 사용 가능)
 *				=> new를 이용해서 저장되는 내용
 *					1. 변수, 2. 메소드 ===> 관리하는 역할 => 객체
 *													 ----
 *													 사용자 정의 데이터형에 대한 변수
 * 			------------------------
 * 			기능 설정 => 메소드 (웹에서는 동작)
 * 							키보드 입력 (검색, 회원가입, 글쓰기,...)
 * 							마우스 클릭 (상세보기)
 * 							메뉴 클릭 => 메소드 (동작)
 * 					=> 메소드의 종류
 * 					1) 일반 메소드 (객체 메소드) => 객체마다 따로 저장되는 메소드
 * 						[접근지정어] 리턴형 메소드(매개변수...)
 * 						{
 * 							=> 기능 처리
 * 						}
 * 					2) 공통 메소드 : 객체가 동일하게 사용하는 메소드
 * 						[접근지정어] static 리턴형 메소드(매개변수...)
 * 						{
 * 							=> 한글 변환, 데이터베이스 연동 ... 디도스 공격
 * 						}
 * 					3) 종단 메소드 : 수정이 불가능한 메소드
 * 						[접근지정어] final 리턴형 메소드(매개변수...)
 * 						=> String / System / Math ... => 있는 그대로 사용
 * 					4) 추상 메소드 : 선언만 되어 있다 => 프로그램에 맞게 구현해서 사용
 * 						=> 윈도우
 * 						버튼 클릭 / 마우스 클릭 / 키보드 입력 ...
 * 						 | 클릭 => 프로그램마다 처리하는 내용이 틀리다
 * 							=> 로그인 버튼, 계산기 버튼, 검색 버튼, 취소 버튼,...
 * 									=> 호출은 가능, 구현은 불가능
 * 						=> 인터페이스
 * 						   ------- 다른 클래스를 연결 시에 주로 사용
 * 						   스프링 <=> 오라클
 * 						   스프링 <=> 자바스크립트 연동
 * 						   ---- 인터페이스 기반
 * 			------------------------ ===========> 한개의 메모리에 저장한 후에 관리하는 역할
 * 														=> 객체 (변수)
 * 														=> 클래스를 저장하는 변수
 * 		}
 */
// 클래스에 선언되는 변수
/*
 * 	Card 설계
 * 	=> number / type => 따로 가지고 있다
 * 	=> width / height => 모든 카드가 동일 => static
 */
class Card
{
	// 각자 사용되는 변수 => 인스턴스
	int number; // 0으로 초기화
	String type; // null로 초기화
	// 아직 저장이 안됨 => new를 사용해야 저장 가능
	
	// 공통으로 사용되는 변수 => 정적 변수 => static
	static int width=200, height=300; // 명시적인 초기화 => 저장 => static은 컴파일 시에 저장
	
	// 프로그램 종료 시까지 메모리가 유지 => Heap (프로그래머가 담당하는 메모리 영역)
	// 지역변수, 매개변수는 밤색
	/*
	 * 		-----------------------------------------------------------
	 * 		종류		메모리 저장 시점		메모리에서 해제		저장 위치		사용 범위
	 * 		-----------------------------------------------------------
	 * 		지역변수	메소드 호출			메소드가 종료		Stack		메소드 안에서만 사용 가능
	 * 				=> 메모리에 저장	return에 해제
	 * 		-----------------------------------------------------------
	 * 	  인스턴스변수	new를 이용할 경우	프로그램 종료 시		Heap	클래스 전체에서 사용 가능
	 * 															=> 다른 클래스에서도 사용 가능
	 * 		-----------------------------------------------------------
	 * 		정적변수	컴파일 시에 저장		프로그램 종료 시		Method Area		클래스 전체에서 사용 가능
	 * 		static													=> 다른 클래스에서도 사용 가능
	 * 		-----------------------------------------------------------
	 * 
	 * 	인스턴스 변수
	 * 	class A
	 * 	{
	 * 		int aa;
	 * 	}
	 * 	=> A a=new A();
	 * 		a는 변수/메소드를 관리하는 공간 => 객체
	 * 		---- a ----
	 * 		  --aa--
	 * 
	 * 		  ------
	 * 		----------- => a.aa (.은 메모리 주소 접근 연산자)
	 * 						=> a 주소 안에 저장되어 있는 aa라는 변수에 접근
	 * 
	 * 	정적 변수
	 * 	static
	 * 
	 * 	class A
	 * 	{
	 * 		static int a; => new 없이 저장 가능 => 모든 클래스에서 공통으로 사용되는 변수
	 * 	}
	 *  => A aa=new A();
	 *  => aa.a => 객체를 통하여 접근 가능
	 *  => A.a => 클래스명으로 접근 가능
	 */
}
public class 클래스_1 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		// 카드 1장 저장
		Card card1=new Card();
		System.out.println("card1="+card1); // card1=Card@1eb44e46
											// 실제 저장되어 있는 주소
		// 변수의 초기화
		card1.number=3;
		card1.type="♠";
		System.out.println("number="+card1.number); // number=3
		System.out.println("type="+card1.type); // type=♠
		System.out.println("width="+card1.width); // width=200
		System.out.println("type="+card1.height); // type=300
		/*
		 * 		static => 별도의 영역에 따로 1개만 저장된다 => card1, card2 모두 접근 가능
		 * 
		 * 		----- card 1 -----
		 * 		저장된 메모리 주소
		 * 		Card@1eb44e46	↘
		 * 		------------------	Card@1eb44e46 -------------
		 *											------- 
		 *												3 => number => card1.number
		 *											-------				(주소.변수)
		 *
		 *											-------
		 *												♠ => type => card1.type
		 *											-------
		 */
		Card card2=new Card(); // new를 이용할 때마다 주소가 계속해서 바뀐다
		card2.number=5;
		card2.type="§";
		System.out.println("card2="+card2); // card2=Card@e73f9ac
		System.out.println("number="+card2.number); // number=5
		System.out.println("type="+card2.type); // type=§
		System.out.println("width="+card2.width); // width=200
		System.out.println("type="+card2.height); // type=300
		
		// static 변수 변경 => 같은 메모리 공간을 제어 => 모든 변경
		card1.width=300;
		card1.height=500;

		card2.width=1200;
		card2.height=1500;
		
		Card.width=700;
		Card.height=1000;
		
		System.out.println("width="+card1.width); // width=700
		System.out.println("type="+card1.height); // type=1000
		System.out.println("width="+card2.width); // width=700
		System.out.println("type="+card2.height); // type=1000
		System.out.println("width="+Card.width); // width=700
		System.out.println("type="+Card.height); // type=1000
		
		// static 변수 => 같은 영역 내에 있기 때문에 최종값으로 나온다
		
		card1.number=7;
		card1.type="◀";

		card2.number=11;
		card2.type="♬";
		
		System.out.println("card1.number="+card1.number); // card1.number=7
		System.out.println("card1.type="+card1.type); // card1.type=◀
		System.out.println("card2.number="+card2.number); // card2.number=11
		System.out.println("card2.type="+card2.type); // card2.type=♬
		
		// 인스턴스 변수는 따로 생성되는 변수이기 때문에 주소가 다르다 => 다른 영역
		
		/*
		 * 	프로그램에서 데이터 관리 => React / Vue => 데이터 관리
		 * 	-----------------
		 * 	변수 => 배열 => 클래스	연산자/제어문 => 변경(X)
		 * 	=> 파일 => 오라클
		 * 
		 * 	공통 저장 : static => 정적 변수 => 컴파일 시에 생성
		 * 	따로 저장 : 변수 선언 => 인스턴스 변수 => 메모리가 별도로 생성 (new)
		 */

	}

}
