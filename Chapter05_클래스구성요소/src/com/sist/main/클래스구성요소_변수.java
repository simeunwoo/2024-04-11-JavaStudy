package com.sist.main;
/*	******* 자바 / 오라클 => 집중적으로 공부를 많이 해야 ...
 * 			나머지 => 프로그램들 => 흐름 파악 위주로
 * 			(참고 사항, 무조건은 아님)
 * 
 * 	클래스 구성 요소
 * 	------------
 * 	*** 클래스 블록
 * 	class ClassName
 * 	{
 * 		=> 구현 불가능
 * 		=> 선언만 가능
 * 		   ---------
 * 			1. 변수 : 한개만 저장 가능
 * 			2. 클래스 (사용자 정의 데이터형) : 여러개 저장 가능
 * 			3. 배열 : 여러개 저장 가능
 * 	}
 * 
 * 	선언 : int a ...
 * 	구현 : 제어문 / 연산 처리 / 파일 읽기 / 크롤링 / 메소드 호출 ... => 메소드 처리, 생성자, 초기화 블록을 이용 
 * 	------------------------
 * 	변수 : 프로그램에 필요한 데이터를 저장 공간 => 프로그램 종료 시까지 유지하는 변수 => 멤버변수
 * 			=> 자동 초기화 (default)
 * 	------------------------
 * 	### 변수 => 초기화 (변수는 초기값이 없는 상태에서는 메모리에 저장이 안됨)
 * 
 * 	### 생성자 => 특징 : 일반 메소드와 다르다
 * 		1) 클래스명과 동일
 * 		2) 리턴형이 없다 => void(리턴형) (X)
 * 			예) class A
 * 				{
 * 					void A(){} => 일반 메소드
 * 					A(){} => 생성자
 * 				}
 * 		3) 여러개의 생성자를 만들 수 있다
 * 		같은 이름의 메소드를 여러개 제작 가능 (오버로딩)
 * 		= 오버로딩 : 같은 이름의 메소드로 새로운 기능을 추가
 * 		1. 메소드명이 동일
 * 		2. 매개변수의 갯수나 데이터형이 다르다
 * 		3. 리턴형은 관계 없다
 * 		4. 접근지정어는 관련이 없다
 * 		예) plus(int a,int b) => plus(int,int)
 * 			plus(double d, double d2) => plus(double,double)
 * 			plus(int a,double d)
 * 			메소드 이름이 다 다르면 나중에 설계할 때 다 찾아오기 힘들어서 => 메소드 이름을 같게 만들 수 있다
 * 		4) 생성자의 역할 => 역할이 필요 없는 경우도 있기 때문에 생략 가능
 * 			*** 반드시 생성자는 필요하다
 * 			*** 생략이 된 경우에는 생성자를 추가 (컴파일러)
 * 			1. 멤버변수의 초기화를 담당
 * 			2. 클래스를 메모리에 저장할 때 호출되는 메소드
 * 			3. 시작과 동시에 처리해야하는 기능이 있는 경우 : 화면 UI, 오라클 연결, 서버 연결, 웹 => 자동 로그인
 * 		5) 생성자 호출
 * 			=> new 생성자() : new 없이 호출하면 오류 발생
 * 
 * 	### 초기화 블록 : 호출 없이 자동으로 처리
 * 		인스턴스 변수
 * 		{
 * 			구현 후 초기화
 * 		}
 * 		정적 변수 (static)
 * 		{
 * 			static 변수의 초기화
 * 		}
 * 
 * 		*** 초기화 방법
 * 		1) 명시적인 초기화
 * 			int a=100;
 * 		2) 초기화 블록
 * 			int a;
 * 			{
 * 				a=100; => 파일 읽기, 웹 => 구현이 필요한 부분
 * 			}
 * 		3) 생성자
 * 			int a;
 * 			생성자()
 * 			{
 * 				a=100; => 파일 읽기, 웹 => 구현이 필요한 부분
 * 			}
 * 		class A
 * 		{
 * 			int a=10,b=20,c=30,d=40,e=50; => 0값 초기화 => 10 20 30 40 50
 * 			=> random() => 초기화 블록, 생성자 : 반드시 필요한 부분이 아니다
 * 		}
 * 
 * 		===> 저장되는 순서
 * 		기본값 => 명시적인 초기값 => 초기화 블록 => 생성자
 * 				------------------------------ 동시에 사용하지 않는다
 * 	예)
 * 	class ClassName
 * 	{
 * 		int a=100; => 고려 => 중복이 없는 난수 값을 저장 => 명시적인 초기화가 불가능 (구현)
 * 	//	int a; => 구현 => 오류 발생
 * 	//	a=100; => 구현 => 오류 발생
 * 		{
 * 			a=200;
 * 		}
 * 
 * 		ClassName()
 * 		{
 * 			a=300;
 * 		}
 * 	}
 * 	===> a 값 : 0 => 100 => 200 => 300 => 프로그램 시작 (a=300)
 * 
 * 	따라서,
 * 	class ClassName
 * 	{
 * 		int a=300;
 * 	}
 * 	===> 간단하게, 효율적으로
 * 
 * 	클래스에서는 선언 / 선언과 동시에 초기화
 * 	int a;
 * 	int a=100;
 * 
 * 	=> int a;
 * 		a=100; => {}
 * 	------------------------
 * 	메소드 : 특정 기능을 수행하는 명령문의 집합 => 검색, 목록, 페이지 나누기, 예약, 결제, 회원 가입, 회원 탈퇴 ...
 * 	1. 재사용
 * 	2. 기능별로 나눠져 있다 => 수정
 * 	3. 반복 기능을 제거
 * 	4. 구조적인 프로그램 (2번 동일)
 * 	5. 역할 : 기능 수행, 다른 클래스와 연결
 *
 *	=> 객체 지향 프로그램
 *		여러개의 클래스를 모아서 조립하는 프로그램 => 다른 클래스와 연동
 *
 *	기능
 *		CPU / 하드 디스크 / 모니터 / 메모리 => 기능을 구현
 *		----------------------------
 *					|
 *				  메인 보드
 *		=> 클래스 1개 부품
 *		=> 조립 (CBD) : Component : 클래스 (한개 기능 => 게시판)
 *		=> 여러개 만든다
 *		=> 조립
 *		=> 레고
 *		=> 묶어주는 역할 : Container
 *
 *	= 메소드 형식 (140page)
 *		[접근지정어] [옵션] 리턴형 메소드명(매개변수 목록) => 선언부
 *		{
 *			// 구현부 (항상 괄호 안에 들어 있는 부분이 구현부이다)
 *			return 값 => 데이터형에 해당되는 값
 *			// void : 결과값이 없는 경우 => return 생략 가능 : 자동으로 추가 (컴파일러)
 *		}
 *	
 *	리턴형 : 데이터형
 *
 *	*** 접근지정어
 *		private : 자신의 클래스 안에서만 사용 => 다른 클래스와 연결할 수 없다 => 멤버변수 (데이터 보호)
 *		default : 키워드가 없는 상태 => 같은 패키지 안에서만 접근 가능
 *		protected : 같은 패키지 안에서만 접근 가능 + 상속을 받은 경우에는 다른 패키지 접근 가능
 *		public : Open 모드 => 패키지와 관계 없이 모든 클래스에서 접근 가능
 *
 *		*** private : 접근 거부 => 다른 클래스에서 사용 불가 => 개인 정보 => 멤버변수
 *				=> 메소드 (변수의 기능) : 메모리 값 읽기 (getter) => public get변수명(), 메모리 저장 (setter) => public set변수명()
 *				=> 변수는 메모리에 값이 저장 => 노출 (변경, 상실 방지)
 *				=> 메소드는 주소값만 저장 => 노출이 없다
 *				=> 캡슐화
 *		*** public : 접근 가능 => 다른 클래스와 연결 가능 => 생성자 / 클래스 / 메소드 / 인터페이스
 *
 *	*** 옵션
 *
 *	@@@ 접근지정어 사용 방법
 *	
 *	=> 1. 클래스
 *	[접근지정어] [옵션] class ClassName
 *	{
 *	}
 *	접근지정어 : public => 다른 클래스와 연결
 *	옵션 : static / abstract / final
 *
 *	=> 2. 생성자 : 다른 클래스와 연결
 *	[접근지정어] 클래스명()
 *	접근지정어 : public
 *	{
 *		// 구현
 *	}
 *
 *	=> 3. 멤버변수
 *	[접근지정어] [옵션] 데이터형 변수명 => 배열, 클래스
 *	접근지정어 : private : 개인 정보, 회사 정보 => 노출하면 안되는 정보 / public : 라이브러리 클래스, 버튼, 테이블 => 연결 => 윈도우와 관련
 *	옵션 : static : 공통으로 사용하는 변수 => 메모리 공간 1개만 만든다
 *	*** 일반 => 인스턴스 : 메모리가 따로 있다
 *	*** 데이터 묶음 => static : 데이터 관리
 *	회원 목록 / 게시판 목록 => 한개만 가지고 사용
 *
 *	=> 4. 메소드
 *	[접근지정어] [옵션] 리턴형 메소드명(매개변수 목록)
 *	접근지정어 : public
 *	옵션 : static : 공통으로 사용 => 한글 변환, 암호화, 복호화 / abstract
 *	리턴형 (요청 결과값) : 기본형, 배열, 클래스
 *	매개변수 (사용자 요청값) : 0 이상 / 매개변수가 없을 수도 있다 => 매개변수가 3개 이상일 경우 추가하지 않고 배열/클래스로 활용
 *
 *	=> 경우의 수
 *	-----------------------------------
 *				리턴형		매개변수
 *				요청처리값		사용자요청값
 *	-----------------------------------
 *				O			O		=> String
 *										String substring(int s,int e)
 *										s부터 e까지 자른 문자열을 달라
 *	-----------------------------------
 *				O			X		=> String trim() : 공백을 제거한 문자열
 *									=> String ToUpperCase() : 대문자로 변환 후의 문자열
 *	-----------------------------------
 *				X			O		=> void System.out.println(String s)
 *										s를 출력하라
 *										=> 메소드 자체 처리 => 결과값이 없다 : void
 *										=> 오라클에 추가, 수정, 삭제
 *	-----------------------------------
 *				X			X		=> 사용 빈도가 거의 없다
 *										void System.out.println() : 다음줄에 출력
 *	-----------------------------------
 *	
 *	= 메소드 호출
 *		class A
 *		{
 *			private int a;
 *			private int b;
 *			private static int c; // 저장 : static이 있으면 변수/메소드는 컴파일 시에 저장
 *			private static int d;
 *			public void aaa(){}
 *			public static void bbb(){} // 저장
 *			public int ccc(){}
 *			public static void ddd(){} // 저장
 *		}
 *
 *	static 저장 => Method Area
 *	(시작하자마자 저장)
 *		0 => c => A.c => 클래스명.변수
 *		bbb() => A.bbb() => 클래스명.메소드명()
 *		ddd() => 결과값을 받는다 => int result=A.ddd() => A.ddd()와 같이 리턴형이 있는 경우에는 결과값을 받아서 저장
 *
 *	나머지
 *		A aa=new A();
 *	
 *	Stack
 *	-- aa --
 *	0x100	=> 메모리 주소에 있는 메소드나 변수를 가지고 온다 => . => aa. (.는 메모리 주소 접근 연산자)
 *	--------
 *
 *	Heap
 *	-------- 0x100
 *	0 => a => 객체명.변수명 => aa.a
 *	--------
 *	0 => b => aa.b
 *	--------
 *	aaa() => 객체명.메소드명() => aa.aaa()
 *	--------
 *	ccc() => 리턴형이 있는 경우 : int result=aa.ccc()
 *	--------
 *
 *	메소드 수행
 *	--------
 *	public int aaa()
 *	{
 *		1. 문장
 *		2. 문장
 *		3. 문장
 *		return 10;
 *	}
 *
 *	int a=aaa() => 호출
 *	1. 문장
 *	2. 문장
 *	3. 문장
 *	===========> a에 10을 대입한다 === 밑에 문장 수행
 *	호출 => 메소드에 있는 모든 문장을 수행 => 호출된 위치 복귀
 *	메소드는 호출 시마다 => 메소드 처음부터 다시 수행
 *
 * 	------------------------
 * 	=> 패키지 / 임포트
 * 	=> 데이터 보호 : 캡슐화
 * 	=> 상속 / 포함
 * 	=> 오버라이딩 / 오버로딩
 * 	------------------ 객체 지향 프로그램
 * 	예외 처리 / 클래스 종류 / 라이브러리 사용 / 구현
 * 
 * 	*** 개념 : 면접
 * 		=> 1. 형식, 2. 사용 방식, 3. 조립 => 기능
 * 					 ------- 메소드 호출 / 초기화
 * 			  ----------------------------- 요구 사항 분석 => 구글링 / GPT
 * 	개념 => 자바 / Spring
 * 	자바 면접 => 객체 지향 프로그램 / 예외 처리 / 컬렉션
 * 
 * 	*** 프로그램에서는 특별한 경우가 아니면 static 메소드는 사용 빈도가 거의 없다 => 주로 인스턴스 메소드 사용 : 웹
 * 	static 메소드 사용 : 데이터베이스 / 네트워크 프로그램을 제어
 */
public class 클래스구성요소_변수 {
//	int a;
//	a=100; // 따로 구현하면 오류 발생
	
/*	int a;
	{
		a=100; // 요런식으로 구현해야 함
	} */
	
	// 저장이 안된 상태 => 인스턴스 (new를 이용하여 저장)
	/*
	 * 	인스턴스 : 객체 (인스턴스 == 객체)
	 * 		클래스의 내용 : 변수, 메소드 => 메모리에 저장한 상태 => 각자 따로 저장 (객체니깐) => new를 이용해야 사용 가능
	 * 
	 * 	인스턴스 : 변수, 메소드
	 * 	static : 변수, 메소드
	 * 
	 * 	class A
	 * 	{
	 * 		private int a=10; // 객체 자신이 가지고 있는 변수
	 * 		private static int b=20; // 객체마다 공통으로 사용하고 있는 변수
	 * 
	 * 		public void aaa() // 객체 자신이 가지고 있는 메소드
	 * 		{
	 * 			=> ccc() / a / b => 사용 가능
	 * 		}
	 * 		public static void bbb() // 객체마다 공통으로 사용되는 메소드
	 * 		{
	 * 			=> b만 사용 가능 => static에서는 static으로 선언된 변수/메소드만 가능
	 * 			=> aaa(), bbb(), a
	 * 			A aa=new A(); => 객체 선언 후 사용 가능
	 * 		}
	 * 		public void ccc() // 객체 자신이 가지고 있는 메소드
	 * 		{
	 * 			=> aaa() / a / b
	 * 		}
	 * 		인스턴스 메소드는 클래스에 있는 모든 데이터/메소드 사용 가능
	 * 	}
	 * 
	 * 	메소드는 호출이 되면 => return이 있는 곳까지 수행
	 */
	public void aaa()
	{
		System.out.println("aaa() 진입 ...");
		bbb();
		System.out.println("aaa() 종료 ...");
		return;
	}
	public void bbb()
	{
		System.out.println("bbb() 진입 ...");
		ccc();
		System.out.println("bbb() 종료 ...");
		// return을 생략 (void일 때만 가능) => 자동 추가 => 마지막에 return이 있다고 봐야
	}
	public void ccc()
	{
		System.out.println("ccc() 진입 ...");
		System.out.println("ccc() 종료 ...");
		// return을 생략 (void일 때만 가능) => 자동 추가 => 마지막에 return이 있다고 봐야
	}
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		// 객체 생성 후에 메소드를 사용할 수 있다
		클래스구성요소_변수 aa=new 클래스구성요소_변수();
		aa.aaa();
/*
aaa() 진입 ...
bbb() 진입 ...
ccc() 진입 ...
ccc() 종료 ...
bbb() 종료 ...
aaa() 종료 ...
 */
	}

}
