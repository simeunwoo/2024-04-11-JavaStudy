package com.sist.main;

import java.lang.reflect.Method;
import java.util.Scanner;

/*
 * 	프로그램의 구성
 * 	------
 * 	# 데이터 저장 => 메모리 / 파일 / 데이터베이스(오라클)
 *                      ---------------------> 자바에서 제어가 불가능
 *                 |
 *                자바에서는 파일/데이터베이스에서 읽은 데이터를 메모리에 저장 후에 관리
 *                
 *  # 자바에서 사용하는 용어
 *  
 *  변수 / 상수 => 한개의 데이터를 저장하는 공간
 *  	=> 변수 : 변경이 가능 / 상수 : 변경이 불가능 (final 사용)
 *  	=> 저장 공간의 크기 (데이터형)
 * 		---------------------------------------------------------------------------
 *  	정수
 * 		byte (1byte) : -128~127 => overflow
 * 			=> 웹 (파일 업로드 / 파일 다운로드), application (네트워크 전송)
 * 			=> 웹 : WebSocket
 * 			=> application : 채팅/쪽지 보내기 => Socket
 * 		int (4byte) : 프로그램에서 사용하는 모든 정수는 int를 인식한다 => -21억4천~21억4천
 * 		long (8byte) : 금융권 / 공기업 / 빅데이터 / AI
 * 			=> 오라클에서 보내준 데이터를 받는 경우 => NUMBER NUMBER(4) => int
 *		---------------------------------------------------------------------------
 * 		실수
 * 		double (8byte) : 일반적인 실수를 저장할 때 사용하는 공간 => NUMBER(7,2) => double
 * 		---------------------------------------------------------------------------
 * 		문자/문자열
 * 		String : 웹, 윈도우 => 가장 많이 사용되는 데이터형
 * 		오라클에는 존재하지 않는다 (CHAR, NUMBER)	
 *		---------------------------------------------------------------------------
 *		논리형
 *		boolean (1byte) : true/false 
 *		---------------------------------------------------------------------------
 *
 * 	# 오라클 컬럼과 매칭
 * 
 *      EMPNO     NOT NULL NUMBER(4)     ===> int empno (사번)
 *      ENAME              VARCHAR2(10)  ===> String ename (이름)
 *      JOB                VARCHAR2(9)   ===> String job (직위)
 *      MGR                NUMBER(4)     ===> int mgr (사수 번호)
 *      HIREDATE           DATE          ===> Date hiredate (입시일)
 *      SAL                NUMBER(7,2)   ===> double sal (급여)
 *      COMM               NUMBER(7,2)   ===> double comm (성과급)
 *      DEPINO             NUMBER(2)     ===> int deptno (부서 번호)
 * 		=================================================================
 * 		숫자형 (NUMBER => int, double)
 * 		문자형 (CHAR/VARCHAR2/CLOB => String)
 * 			CHAR : 1~2000, VARCHAR2 : 1~4000, CLOB : 4기가
 * 			*** 한글 한글자당 3byte
 * 		날짜형 (DATE => java.util.Date)
 * 
 * 	# 웹에 출력된 데이터 : 데이터 추출 (데이터형)
 * 		*** 변수 / 클래스 / 배열 => 난발하면 프로그램을 짜기 어렵다 => 한개의 이름으로 제어 => 모음
 * 
 *  # 데이터가 많은 경우에 데이터를 모아서 관리
 *  	=> 묶어서 사용 : 반복문 사용 => 소스를 간결하게 만든다
 *  	int a~z => 26개의 변수 설정 => 가장 큰값, 작은값 출력 => if문 25개 작은 25개 => 50개의 if문 사용
 *  	=> 같은 데이터형을 묶어서 한개의 이름으로 제어
 *  		=> 배열 (구분자 : 인덱스) => 개수 지정
 *  		데이터형[] 배열명=new 데이터형[개수]
 *  	=> 다른 데이터형이 여러개 존재 => 한개의 이름으로 제어
 *  		=> 클래스 (구분자 : 메모리 주소값 => 객체) => new 생성자() => 따로 저장된다
 *  		=> 한개의 이름으로 모아서 관리 : 인터페이스, 컬렉션
 *  	*** 정수 n개 => 배열
 *  	*** 클래스 n개 => 컬렉션 : 배열의 단점을 보완
 *  
 *  # 변수의 종류
 *  
 *  --- 메소드에서만 사용 가능 ----------------------------------------
 *  1. 지역 변수 : 메소드 안에 선언되는 변수 => 루프 변수, 결과값을 전송하는 변수
 *  2. 매개 변수 : 사용자가 보내준 요청 (사용자가 요청값)
 *  	=> 3개 이상 초과하지 않는다 (배열, 클래스)
 *  --- 프로그램 종료 시까지 사용 가능 (다른 클래스에서도 사용 가능 )------------
 *  3. 인스턴스 변수 : 메모리 공간이 따로 생기는 공간 => new 사용 시마다 생성
 * 	4. 공유 변수 (정적 변수) : 모든 객체가 공통으로 사용 가능 => 한개의 메모리 생성
 * 	-------------------------------------------------------------
 * 
 * 	===> 자바에서 지원하는 메모리 공간
 * 
 * 	--- Method Area --------------------------------
 * 	Method가 저장 (Method는 메소드명이 주소)
 * 	공유 변수 (static)
 * 	--- Stack --------------------------------------
 * 	메모리 자체 관리 => {}이 끝나면 자동으로 회수
 * 	지역 변수 / 매개 변수
 * 	--- Heap ---------------------------------------
 * 	인스턴스 변수 => new
 * 	클래스 / 배열
 * 	프로그래머가 관리 => 메모리 해제 (객체가 null인 경우, 사용하지 않는 변수) => GC
 * 		new => delete
 * 		malloc() => free()
 * 		=> 자동 메모리 회수기를 이용한다 (가비지 컬렉션)
 * 	------------------------------------------------
 * 	
 *	# 연산자
 *
 * 	> 단항연산자
 * 
 * 		= 증감연산자 : ++, --
 * 
 * 		= 부정연산자 : ! : 반대 => true/false 관련
 * 			String finddata="";
 * 			=> if(data.contains(finddata))
 * 			=> if(!data.contains(finddata))
 * 			=> 예약일 / 예약이 없는 날
 * 
 * 		= 형변환연산자 : (데이터형) => ***** 클래스도 데이터형 => ex) Sawon, Student ... => 라이브러리/사용자 정의가 될 수 있다
 * 			왼쪽에서 받는 변수(클래스)가 크거나 같다
 * 			값을 받는 데이터 = 대입할 값
 * 			기본 데이터형 크기
 * 						-----> UpCasting : 자동 형변환
 * 			byte < char < int < long < float < double
 * 						<----- DownCasting : 강제 형변환
 * 			클래스 크기 : 상속 / 포함 => 클래스는 위로 올라갈수록 크다 => 상속도 : extends 활용
 * 			=> 상속을 받은 클래스 < 상속을 내리는 클래스
 * 			=> 포함된 클래스 < 포함하고 있는 클래스
 * 
 * 		= 전치연산자 / 후치연산자 => a++ : 무조건 1개 증가, a-- : 무조건 1개 감소 => 반복문에서 주로 사용
 * 
 * 	> 이항연산자 => 형변환 (자동)
 * 
 * 		*** 프로그램 언어는 연산 시에 같은 데이터형만 연산 가능 => 큰 데이터형으로 변경 후 수행
 * 		'A' + 1 => char + int => int로 변경 후에 연산 => 65 + 1 => 66
 * 		10 + 10.5 => int + double => double로 변경 후에 연산 => 10.0 + 10.5 => 20.5
 * 		=> 작은 데이터형으로 통합 가능 => 10 + (int)10.5
 * 
 * 		= 산술연산자 : +, -, *, /, %
 * 			+ : 산술연산, 문자열 결합
 * 			/ : 0으로 나눌 수 없다, 정수/정수=정수(5/2=>2, *** 오라클/자바스크립트에서는 5/2=>2.5)
 * 			% : 남는 것이 왼쪽 부호를 따라간다
 * 			*** 산술 규칙
 * 			int + int = int 
 * 			int + long = long
 * 			int + char = int
 * 			int + double = double
 * 			----------------------
 * 			byte + byte = int
 * 			char + char = int
 * 			---------------------- int 이하의 데이터형의 연산 결과는 int로 나온다
 * 
 *      = 비교연산자 : ==, !=, <, >, <=, >=
 *                 --- 같다
 *                 오라클 =, 자바스크립트 === (==)
 *                      <>          !== (!=) => 빨간색(경고)
 *                         ------------------------------- 이클립스 (vsCode, 웹스톰)
 *                         이클립스 : Back-End 편집기
 *                         Front-End => 도움말이 없다 => 컴파일(X) => 인터프리터
 *                         HTML / CSS => 에러가 없다 (화면이 이상하다)
 *                 => 조건/반복문 => boolean
 *                 
 *		= 논리연산자 : &&, || : boolean
 *			=> 두개의 조건이 있는 경우 처리
 *			&& : 두개의 조건이 true일 경우에만 true
 *			|| : 둘 중에 한개의 조건이 true일 경우 true
 *			=> 효율적인 연산
 *				(조건) && (조건) => false일 경우 => 뒤의 조건은 연산하지 않는다
 *				(조건) || (조건) => true일 경우 => 뒤의 조건은 연산하지 않는다
 *
 *		= 대입연산자 : =, +=, -=
 *			+= : 누적 시에 주로 사용 (문자열 누적, 정수 누적 ...)
 *			int a=10;
 *			a+=10 => a=a+10
 *			---------------------
 *			a++
 *			++a
 *			a+=1
 *			a=a+1 => 1개 증가가 동일
 *			--------------------- 자바스크립트와 동일
 *
 * 	> 삼항연산자
 * 
 * 		= if ~ else
 * 			조건?값1:값2
 * 			=> 조건이 true일 경우 => 값1
 * 			=> 조건이 false일 경우 => 값2
 * 			=> 자바에서는 if ~ else 사용 빈도가 많다
 * 			=> 웹에서 주로 사용 => 자바 + HTML => 구분 : <% 자바 소스 %> HTML
 * 		ex)
 * 		<%
 * 			int curpage=1; 
 * 			int totalpage=10'
 *  
 * 			if(curpgae>1) 이전
 * 			{
 * 				curpage--;
 * 		%>
 * 			<a href="list.jsp?page=<%=curpage%>">
 * 		<%
 * 			}
 * 			if(curpage<totalpage) 다음
 * 			{
 * 				curpage++;
 * 		%>
 * 			<a href="list.jsp?page=<%=curpage%>">
 * 		<%
 * 			}
 * 		%>
 * 
 * 		===> 간단하게 바꿀 수 있음
 * 
 * 		<a href="list.jsp?page=<%=curpage>1?curpage--:curpage%>이전
 * 		<a href="list.jsp?page=<%=curpage<totalpage?curpage++:curpage%>">
 * 
 * 		=> 자바 + HTML => JSP => 작은 사이트 제작 => 중소 기업 사이트, 유치원, 학원 ...
 * 		=> 자바 / HTML => 분리 => MVC => 큰 사이트 제작 => 공기업, 금융권 ...
 * 		=> 자바 : Back, HTML : Front
 * 		=> (자바->GIT) : 같은 파일을 제어 => COMMIT이 없어진다
 * 	
 * 	# 제어문
 * 
 * 	=> 묶기 시작 => 한개의 이름으로 제어 => 소스가 간결, 유지 보수가 편리
 * 		=> 관련된 명령문을 묶어서 사용 : 메소드 => 재사용 / 반복 제거 / 에러나 기능을 편리하게 추가
 * 		=> 메소드 + 변수 묶어서 사용 : 클래스
 * 		=> 만들지 못하는 기능 : 라이브러리 (자바에서 클래스를 지원)
 * 	=> 다른 프로그램과 연동
 * 		1. 오라클 연동 => 오라클 명령어 사용법 => JDBC
 * 		2. 브라우저 연동 => HTML / CSS => JSP => 웹 사이트가 제작
 * 
 *      ---------------------------------------------
 *               요청        요청된 데이터를 보내달라
 * 	    브라우저 -------- 자바 -------------------- 오라클
 *             화면 출력       응답 데이터를 보내준다
 *      --------------------------------------------- 통합 (스프링)
 *	> 조건문
 *
 *		= 단일조건문
 *			if(조건) => 조건 (결과값 : true/false) => 부정/비교/논리
 *			{
 *				조건이 true일 때 수행하는 문장
 *			}
 *			=> 독립적으로 되어 있다 => 여러개 사용 시에는 속도가 늦다
 *			=> 웹 : 사용자가 요청값을 전송했는지 여부
 *				=> 오라클에 NOT NULL => 모든 값이 있어야 된다
 *				=> 유효성 검사 : 입력 여부 확인 / 제한된 값
 *
 *		= 선택조건문
 *			if(조건)
 *			{
 *				조건이 true일 때 수행하는 문장
 *			}
 *			else
 *			{
 *				조건이 false일 때 수행하는 문장
 *			}
 *			=> 웹 : 무조건 브라우저로 결과값 전송
 *			=> 정상
 *			=> 비정상
 *			=> ex) 로그인 성공 => main.jsp로 이동 / 로그인 실패 => id, pwd가 틀리다
 *
 *		= 다중조건문 : 해당되는 1개의 조건만 수행
 *			if(조건)
 *			{
 *				조건이 true일 경우 => 문장을 수행하고 종료한다
 *				조건이 false일 경우 => 밑에 있는 조건을 검색한다
 *			}
 *			else if(조건)
 *			{
 *				조건이 true일 경우 => 문장을 수행하고 종료한다
 *				조건이 false일 경우 => 밑에 있는 조건을 검색한다
 *			}
 *			else if(조건)
 *			{
 *				조건이 true일 경우 => 문장을 수행하고 종료한다
 *				조건이 false일 경우 => 밑에 있는 조건을 검색한다
 *			}
 *			else if(조건)
 *			{
 *				조건이 true일 경우 => 문장을 수행하고 종료한다
 *				조건이 false일 경우 => 밑에 있는 조건을 검색한다
 *			}
 *			else
 *			{
 *				해당 조건이 없는 경우 => 수행하는 문장 : default : 생략 가능
 *			}
 *			=> 조건에 맞는 모든 수행 => 단일조건문 여러개
 *			=> 조건에 맞는 문장 한개 => 다중조건문 사용
 *			=> 오라클에서 어려운 부분 => 다중 조건이 있는 경우
 *			=> 맛집
 *				= 맛집명 name name LIKE 
 *				= 테마 theme theme LIKE
 *				= 주소 address address LIKE
 *				= 맛집명+테마 name LIKE AND theme LIKE
 *				= 동적 쿼리 (*******)
 *			---------------------------------------- 웹 + 데이터베이스
 *
 *	> 반복문 : 화면 출력 => HTML(JSP)
 *
 *		= for, for-each
 *			=> 반복 횟수가 지정된 경우
 *          형식)           | false면 종료
 *                    1    2   4
 *              for(초기값;조건식;증가식)
 *              {          | true
 *                  실행 문장 3
 *              }
 *              => 초기값을 증가해서 => 조건이 false일 때 수행
 *              => 초기값 => 조건식 => 실행 문장 => 증가식
 *                      => 조건식 => 실행 문장 => 증가식
 *                      => 조건식 => 실행 문장 => 증가식
 *                      => 조건식 => 실행 문장 => 증가식
 *                      => 조건식 => 실행 문장 => 증가식 ...
 *                           | false면 종료
 *                           
 *              for(데이터형 변수:배열,컬렉션)
 *              {
 *                  실행 문장 => 변수는 실제 저장된 데이터값을 가지고 온다
 *                  *** 데이터형 => 배열, 컬렉션에 저장된 데이터형이 동일/크다
 *              }
 *              => 웹에서 출력 시는 대부분이 => for-each를 사용한다
 *              => 이차 for
 *                 => 자바 개발은 빈도수가 작다
 *                    ------------------
 *                 => 코딩 테스트 (80%)
 *                    코딩 테스트 / 기술 면접 / 테스트지
 *                 => 코딩 테스트 => 중견 업체 (솔루션)
 *                    기술 면접 => 일반 중소기업 (SI/SM)
 *                    테스트지 => 코딩 테스트 + 기술 면접 => 시험지 => 변경
 *                    
 *                         | false면 종료
 *                    1    2   4
 *              for(초기값;조건식;증가식) => 줄수
 *              {          | true
 *                  -------------------------------
 *                             | false면 일차 for문 => 증가식
 *                        1    2   4
 *                  for(초기값;조건식;증가식) => 한줄에 몇개의 데이터 출력
 *                  {          | true
 *                      실행 문장 3
 *                  }
 *                  -------------------------------
 *                  줄수 =>
 *              }
 *              => 별표 출력 / 배열에서 숫자 이동 (90도 회전) / 화폐 매수 구하기 / Stack : LIFO / Queue : FIFO
 *              
 *              수열 ------- 방정식 => 산수
 *              for => 패턴이 있는 경우에만 수행
 *                     -------- 숫자의 패턴 (수열)
 *              1 2 3 4 6 5 4 7 8 1 3 4 => 패턴이 없다 => for문은 어렵다 => 차라리 System.out.println을 써라
 *              1 3 5 7 9 ... => 패턴이 있다 => for문 가능
 *              
 *		= while
 *			=> 반복 횟수가 없는 경우
 *			=> 무한 스크롤
 *			=> 데이터베이스 : 반복 횟수를 알 수 없다
 *				=> 게시판 / 회원 => 데이터가 없을 때까지 반복 : rs.next()
 *			형식)
 *				초기값 1
 *				while(조건문) 2 => false면 종료
 *				{
 *					실행 문장 3
 *					증가식 4 => 2번으로 이동
 *				}
 *
 *				while(조건문) => 데이터베이스에서 주로 사용
 *				{
 *					실행 문장
 *				}
 *
 *			=> 무한 루프 : for(;;) / while(true)
 *				=> 반드시 종료 조건을 설정한다 : esc, 키 선택 시 종료
 *				
 *
 *	> 반복제어문
 *
 *		= break
 *			=> 반복문을 중단하는 경우에 사용
 *      
 *  #
 *  => 오라클 : <>
 *  => 웹 => 대부분은 오라클 명령어를 이용하여 데이터를 추출
 *                ---------- 모든 데이터는 오라클에 저장 후에 사용
 *                                     -----
 *                                     | 영구적인 저장 장치
 *                                     | 모든 사용자가 공유
 *  
 *  #
 *  모든 클래스는 Object로부터 상속을 받는다 (Object : 가장 큰 클래스)
 *  => 리턴형이 Object면 항상 형변환을 해서 사용한다 => 프로그램에 맞게 변경 : 제네릭
 *  
 *  #
 *  자바 : Kotlin, 스칼라, Dart, GO, C#
 *       -------------
 *       잘 모르면 자바 import => 스프링 (Java / Kotlin)
 *  C언어 : C++, MFC, Python, Oracle
 *  
 *  # 배열 : 일차원 배열
 *  
 *  1. 선언
 *  	데이터형[] 배열명; => 권장
 *  	데이터형 배열명[]; => C언어 호환
 *  
 *  2. 초기값
 *  	데이터형[] 배열명={값,값...};
 *  	데이터형[] 배열명=new 데이터형[개수]; => 기본값으로 초기화
 *  
 *  3. 값 변경
 *  	=> 인덱스 이용 => 0번부터 시작
 *  	배열명[0]=값;
 *  
 *  4. 출력
 *  	=> for ~ each : 출력 전용
 *  	=> 값을 변경 => 일반 for문 (인덱스 번호 이용 때문)
 *  
 *  => 단점
 *  	고정적 => 한번 지정하면 변경이 어렵다 (저장 개수)
 *  	-------------------------------------
 *  	개수가 틀린 경우에 처리하기 어렵다
 *  	검색, 데이터베이스 프로그램은 배열 사용이 어렵다 => 가변형 (컬렉션)
 *  => 컬렉션 : ArrayList
 *  
 *  # 메소드 : 명령문을 모아서 관리
 *  
 *  > 리턴형 : 요청에 대한 처리값
 *  	1) 기본형 => int, String => 총 페이지 / 로그인 여부
 *  	2) 데이터가 여러개 => ArrayList => SELECT
 *  	   ----------- 목록 / 검색
 *  	3) 관련된 데이터 => 사용자 정의 데이터형 => SELECt에서 조건이 있는 경우
 *         --------- 상세 보기
 *  
 *  > 매개 변수 : 사용자가 요청한 값 => 입력/클릭 => 브라우저
 *  
 *  > 메소드명 : 약속 => 소문자로 시작 / 운영체제의 호환 => 알파벳을 이용
 *  	=> cp949, euc-kr, utf-8
 *  	=> Git에서 한글 깨짐이 많다
 *  
 *  	1) 형식
 *  	[접근지정어] [제어어] 리턴형 메소드명(매개 변수 목록) => 선언부
 *  	{
 *  		구현부
 *  		return 값; => void일 때만 생략 가능
 *  	}
 *  
 *  	= 접근지정어
 *  		특별한 경우가 아니면 => public => 다른 클래스 통신을 할 수 있게 한다
 *  	= 제어어
 *  		static => 공통 사용 기반 => 데이터베이스 (MyBatis)
 *  		abstract => 선언하는 메소드 => 프로그램에 맞게 구현해서 사용 
 *  
 *  	2) 종류
 *  	리턴형	매개변수
 *  	--------------
 *  	 O		  O => 가장 많이 사용
 *  	 O		  X => 자체에서 처리 결과
 *  	-------------------------------------- SELECT
 *  	 X		  O => 데이터베이스
 *  	 X		  X => 빈도수가 거의 없다
 *  	-------------------------------------- INSERT / UPDATE / DELETE
 *  	사용자 요청 => 검색 결과를 브라우저에 출력 요청
 *  		=> 리턴형 : ArrayList
 *  		=> 매개 변수 : String => 검색어
 *  	맛집의 상세 보기
 *  		=> 리턴형 : Food
 *  		=> 매개 변수 : 맛집 번호 => int
 *  	로그인 요청
 *  		=> 리턴형 : String, int => 가독성
 *  			경우의 수 3가지
 *  			1. ID가 없는 경우
 *  			2. 비밀 번호가 틀린 경우
 *  			3. ID, 비밀 번호가 맞는 경우
 *  			=> "ID나 비밀 번호가 틀립니다" => 사용자 중심의 프로그램
 *  		=> 매개 변수 : id, pwd
 *  	Board에 등록
 *  		=> 리턴형 : 없는 상태 => void
 *  		=> 매개 변수 : 이름, 제목, 내용, 비밀 번호
 *  
 *  	3) 클래스
 *  	=> 구성 요소 => 역할
 *  		class className
 *  		{
 *  			=> 반드시 설정 (접근 범위) => 접근지정어
 *  			--------------------------
 *  			변수
 *  			= 인스턴스 변수 : new 사용 시마다 새로운 메모리 생성
 *  				[접근지정어] 데이터형 변수명; => 라이브러리를 제외하고 사용자 정의 => 은닉화 (기본)
 *  				접근지정어 : private
 *  				변수명 : 기본형(int,long...), 배열, 클래스(String)
 *  			= 공유 변수 (정적 변수->static) => 한개만 생성 : 데이터 묶음 (모든 클라이언트가 동일)
 *  			--------------------------
 *  			생성자, 초기화 블록 => 없는 경우도 존재 => 생성자는 없는 경우에 자동으로 디폴트 생성자 추가
 *  			= 생성자 : 멤버 변수의 초기화 담당
 *  				변수가 명시적인 초기화 가능 : 생성자 (X)
 *  				명시적인 초기화가 아니라 구현 후에 초기화 시에는 사용
 *  				private int a=10;
 *  				=> 파일 읽기 => 데이터 초기화
 *  				=> 데이터베이스에서 데이터 읽기
 *  	*** 클래스
 *  	class ClassName
 *  	{
 *  		선언만 가능
 *  		=> 예외 처리, 메소드 호출, 연산자, 제어문 => 구현 => 사용할 수 없다
 *  	}
 *  
 *  	class ClassName
 *  	{
 *  		{
 *  			try
 *  			{
 *  			}catch(Exception e)
 *  		}
 *  	}
 *  
 *  	=> 가급적이면 인스턴스 초기화 => 생성자
 *  		static 초기화 => static {}
 *  	=> 데이터베이스 드라이버 등록
 *  		화면 UI
 *  		시작과 동시에 처리하는 명령문이 있는 경우
 *  	=> 생성자 => public을 사용한다 => 다른 클래스에서 연결
 *  			= 초기화 블록
 *  			--------------------------
 *  			메소드
 *  			--------------------------
 *  		}
 *  	=> 클래스 종류
 *  		= 추상 클래스
 *  		= 인터페이스
 *  	=> 객체 지향의 3대 특성 : 권장 사항
 *  		=> 데이터 보호 : 캡슐화 ******* 시큐어 코딩의 기본
 *  			=> 데이터 은닉화 : private => 메소드로 접근 : getter / setter
 *  		=> 재사용 : 상속, 포함
 *  		=> 추가/수정 : 오버로딩 / 오버라이딩
 */
/*
	int[] arr=new int[10];
	int o=arr.length-1; // 출력
	int i=0; // 입력
	
	int o=0;
	int i=0;
*/
class Human
{
	public void display()
	{
		System.out.println("Human:display() Call...");
	}
}
class Sawon
{
	public void aaa()
	{
		System.out.println("Sawon:aaa() Call...");
	}
	public void bbb()
	{
		System.out.println("Sawon:bbb() Call...");
	}
	public void ccc()
	{
		System.out.println("Sawon:ccc() Call...");
	}
}
public class 최종정리 {
	public static void main(String[] args) throws Exception {
	/*	int[] arr=new int[10];
		
		for(int i=0;i<arr.length;i++)
		{
			arr[i]=i+1;
		}
		System.out.println(Arrays.toString(arr)); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
		// Stack
		for(int i=arr.length-1;i>=0;i--)
		{
			System.out.print(arr[i]+" "); // 10 9 8 7 6 5 4 3 2 1 
		}
		System.out.println();
		// Queue
		for(int i=0;i<arr.length;i++)
		{
			System.out.print(arr[i]+" "); // 1 2 3 4 5 6 7 8 9 10 
		} */
		
		Human h1=new Human(); // => 결합성이 높다 => 다른 클래스에 영향이 많다
		h1.display();
		
		Human h2=new Human().getClass().getDeclaredConstructor().newInstance();
		h2.display();
		
		Human h3=Human.class.getDeclaredConstructor().newInstance();
		h3.display();
		
		// 가장 많이 사용되는 메모리 할당 : 스프링에서 주로 사용
		Class className=Class.forName("com.sist.main.Human");
		Method[] methods=className.getDeclaredMethods();
		
		Human h4=(Human)className.getDeclaredConstructor().newInstance();
		System.out.println("메소드명 없이 호출");
		methods[0].invoke(h4, null);
		// 매개 변수
		System.out.println("메소드명 사용");
		h4.display();
		
		Class cls=Class.forName("com.sist.main.Sawon");
		Object obj=cls.getDeclaredConstructor().newInstance();
		Method[] ms=cls.getDeclaredMethods();
		
		Scanner scan=new Scanner(System.in);
		System.out.print("호출할 메소드명 입력:");
		String mName=scan.next();
		// Annotation => 구분자 => 스프링
		for(int i=0;i<ms.length;i++)
		{
			String s=ms[i].getName();
			if(mName.equals(s))
			{
		//		System.out.println(i+":"+ms[i].getName());
				ms[i].invoke(obj, null);
			}
		}
	}
}
